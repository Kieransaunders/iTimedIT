// Service Worker for Web Push Notifications with PWA Precaching
import { precacheAndRoute } from 'workbox-precaching';

// Precache all assets generated by Vite PWA plugin
precacheAndRoute(self.__WB_MANIFEST);

self.addEventListener('install', event => {
  console.log('Service Worker installing - auto-update mode');
  // Skip waiting to activate immediately
  self.skipWaiting();
});

self.addEventListener('activate', event => {
  console.log('Service Worker activating - taking control');
  // Take control of all clients immediately
  event.waitUntil(self.clients.claim());
});

self.addEventListener('push', event => {
  console.log('Push received:', event);
  console.log('Has data:', !!event.data);
  
  if (!event.data) {
    console.log('Push event but no data');
    return;
  }

  // Try to get the raw data first
  let rawData;
  try {
    rawData = event.data.text();
    console.log('Raw push data:', rawData);
  } catch (e) {
    console.error('Failed to get raw push data:', e);
  }

  let data;
  try {
    data = event.data.json();
    console.log('Parsed push data:', data);
  } catch (e) {
    console.error('Failed to parse push data as JSON:', e);
    console.log('Attempting to parse as text...');
    try {
      const textData = event.data.text();
      console.log('Text data:', textData);
      // Try to parse the text as JSON
      data = JSON.parse(textData);
      console.log('Successfully parsed text as JSON:', data);
    } catch (e2) {
      console.error('Failed to parse text as JSON:', e2);
      data = {
        title: 'Timer Alert',
        body: event.data.text() || 'Time to check your timer!',
        actions: []
      };
    }
  }

  const options = {
    body: data.body,
    icon: data.icon || '/icons/timer.svg',
    badge: data.badge || '/icons/badge.svg',
    tag: 'timer-alert',
    requireInteraction: true,
    data: data.data || {},
    actions: normalizeActions(data.actions),
    vibrate: data.vibrate || [200, 100, 200],
    timestamp: Date.now(),
    // Add URL for macOS system notifications
    url: data.data?.url || '/'
  };

  event.waitUntil(
    Promise.all([
      self.registration.showNotification(data.title || 'Timer Alert', options),
      // Set badge count when notification is shown
      setBadgeCount(data.badgeCount || 1)
    ])
  );
});

// Helper function to set badge count
async function setBadgeCount(count) {
  try {
    if ('setAppBadge' in navigator) {
      if (count === 0) {
        await navigator.clearAppBadge();
        console.log('Badge cleared in service worker');
      } else {
        await navigator.setAppBadge(count);
        console.log('Badge set to:', count, 'in service worker');
      }
    }
  } catch (error) {
    console.error('Error setting badge in service worker:', error);
  }
}

function normalizeActions(rawActions) {
  if (Array.isArray(rawActions) && rawActions.length > 0) {
    return rawActions;
  }

  return [
      {
        action: 'stop',
        title: 'Stop Timer',
        icon: '/icons/stop.svg'
      },
      {
        action: 'snooze',
        title: 'Snooze 5min',
        icon: '/icons/snooze.svg'
      },
      {
        action: 'switch',
        title: 'Switch Project',
        icon: '/icons/switch.svg'
      }
    ];
}

self.addEventListener('notificationclick', event => {
  console.log('Notification clicked:', event);
  console.log('Action:', event.action);
  console.log('Data:', event.notification.data);

  event.notification.close();

  // Clear badge when notification is interacted with
  setBadgeCount(0);

  const action = event.action;
  const data = event.notification.data || {};
  // Try multiple sources for the URL
  const targetUrl = data.url || event.notification.url || '/';
  
  console.log('Target URL:', targetUrl);
  console.log('Notification URL:', event.notification.url);
  console.log('Data URL:', data.url);

  // Handle notification actions
  if (action === 'stop') {
    // Focus the app and send stop action
    event.waitUntil(
      focusOrOpenApp(targetUrl).then(client => {
        if (client) {
          client.postMessage({
            type: 'TIMER_ACTION',
            action: 'stop',
            data: data
          });
        }
      })
    );
  } else if (action === 'snooze') {
    // Focus the app and send snooze action
    event.waitUntil(
      focusOrOpenApp(targetUrl).then(client => {
        if (client) {
          client.postMessage({
            type: 'TIMER_ACTION',
            action: 'snooze',
            data: data
          });
        }
      })
    );
  } else if (action === 'switch') {
    // Focus the app and send switch action
    event.waitUntil(
      focusOrOpenApp(targetUrl).then(client => {
        if (client) {
          client.postMessage({
            type: 'TIMER_ACTION',
            action: 'switch',
            data: data
          });
        }
      })
    );
  } else if (action === 'continue') {
    // Backwards compatibility for older notifications using continue
    event.waitUntil(
      focusOrOpenApp(targetUrl).then(client => {
        if (client) {
          client.postMessage({
            type: 'TIMER_ACTION',
            action: 'continue',
            data: data
          });
        }
      })
    );
  } else {
    // Default click - just focus the app
    console.log('Default notification click - focusing app');
    event.waitUntil(focusOrOpenApp(targetUrl));
  }
});

self.addEventListener('notificationclose', event => {
  console.log('Notification closed:', event);
  // Clear badge when notification is dismissed
  setBadgeCount(0);
  // Track notification dismissal for analytics if needed
});

async function focusOrOpenApp(url = '/') {
  const urlToOpen = new URL(url, self.location.origin).href;
  console.log('Attempting to focus/open app at:', urlToOpen);

  // Get all clients (open tabs/windows)
  const allClients = await self.clients.matchAll({
    type: 'window',
    includeUncontrolled: true
  });

  console.log('Found clients:', allClients.length);

  // Check if the app is already open - be more specific about matching
  let clientToFocus = null;
  for (const client of allClients) {
    console.log('Checking client URL:', client.url);
    const clientOrigin = new URL(client.url).origin;
    const targetOrigin = new URL(urlToOpen).origin;
    
    if (clientOrigin === targetOrigin) {
      clientToFocus = client;
      break;
    }
  }

  if (clientToFocus) {
    console.log('Focusing existing client');
    // For Safari, try to focus first
    try {
      if ('focus' in clientToFocus) {
        await clientToFocus.focus();
      }
      // Navigate to the specific URL if different
      if ('navigate' in clientToFocus && clientToFocus.url !== urlToOpen) {
        await clientToFocus.navigate(urlToOpen);
      }
      return clientToFocus;
    } catch (error) {
      console.error('Error focusing client:', error);
      // Fall back to opening new window
    }
  }
  
  // Open new window/tab or if focusing failed
  console.log('Opening new window');
  try {
    const newClient = await self.clients.openWindow(urlToOpen);
    return newClient;
  } catch (error) {
    console.error('Error opening new window:', error);
    return null;
  }
}

// Handle messages from the main app
self.addEventListener('message', event => {
  console.log('Service Worker received message:', event.data);
  // Messages can be used for custom functionality if needed
});
